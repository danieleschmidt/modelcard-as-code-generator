# Continuous Deployment Workflow for Model Card Generator
# Automated deployment to staging and production environments

name: CD

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean

concurrency:
  group: cd-${{ github.ref }}-${{ github.event.inputs.environment || 'auto' }}
  cancel-in-progress: false  # Don't cancel deployments

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: terragonlabs/modelcard-generator
  PYTHON_VERSION: "3.11"

jobs:
  # ==========================================================================
  # Determine Deployment Strategy
  # ==========================================================================
  strategy:
    name: Deployment Strategy
    runs-on: ubuntu-latest
    outputs:
      deploy-staging: ${{ steps.strategy.outputs.deploy-staging }}
      deploy-production: ${{ steps.strategy.outputs.deploy-production }}
      version: ${{ steps.strategy.outputs.version }}
      is-release: ${{ steps.strategy.outputs.is-release }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine deployment strategy
        id: strategy
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual deployment
            if [[ "${{ github.event.inputs.environment }}" == "staging" ]]; then
              echo "deploy-staging=true" >> $GITHUB_OUTPUT
              echo "deploy-production=false" >> $GITHUB_OUTPUT
            else
              echo "deploy-staging=false" >> $GITHUB_OUTPUT
              echo "deploy-production=true" >> $GITHUB_OUTPUT
            fi
            echo "is-release=false" >> $GITHUB_OUTPUT
            echo "version=manual-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            # Tag release - deploy to production
            echo "deploy-staging=false" >> $GITHUB_OUTPUT
            echo "deploy-production=true" >> $GITHUB_OUTPUT
            echo "is-release=true" >> $GITHUB_OUTPUT
            echo "version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            # Main branch - deploy to staging
            echo "deploy-staging=true" >> $GITHUB_OUTPUT
            echo "deploy-production=false" >> $GITHUB_OUTPUT
            echo "is-release=false" >> $GITHUB_OUTPUT
            echo "version=main-$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          else
            echo "deploy-staging=false" >> $GITHUB_OUTPUT
            echo "deploy-production=false" >> $GITHUB_OUTPUT
            echo "is-release=false" >> $GITHUB_OUTPUT
            echo "version=unknown" >> $GITHUB_OUTPUT
          fi

  # ==========================================================================
  # Wait for CI to Complete (if not forced)
  # ==========================================================================
  wait-for-ci:
    name: Wait for CI
    runs-on: ubuntu-latest
    if: ${{ !github.event.inputs.force_deploy }}
    steps:
      - name: Wait for CI workflow
        uses: lewagon/wait-on-check-action@v1.3.1
        with:
          ref: ${{ github.sha }}
          check-name: 'CI Success'
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 30
          allowed-conclusions: success

  # ==========================================================================
  # Build and Push Docker Images
  # ==========================================================================
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [strategy, wait-for-ci]
    if: always() && (needs.wait-for-ci.result == 'success' || needs.wait-for-ci.result == 'skipped')
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          target: runtime
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ github.run_id }}
            VERSION=${{ needs.strategy.outputs.version }}
            VCS_REF=${{ github.sha }}

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.strategy.outputs.version }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Upload SBOM
        uses: actions/upload-artifact@v3
        with:
          name: sbom
          path: sbom.spdx.json
          retention-days: 30

  # ==========================================================================
  # Security Scanning of Images
  # ==========================================================================
  scan-images:
    name: Security Scan Images
    runs-on: ubuntu-latest
    needs: [build-images]
    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build-images.outputs.image-tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # ==========================================================================
  # Deploy to Staging
  # ==========================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [strategy, build-images, scan-images]
    if: needs.strategy.outputs.deploy-staging == 'true'
    environment:
      name: staging
      url: https://staging.modelcard-generator.terragonlabs.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging environment
        run: |
          echo "üöÄ Deploying to staging..."
          echo "Image: ${{ needs.build-images.outputs.image-tag }}"
          echo "Version: ${{ needs.strategy.outputs.version }}"
          
          # Here you would typically:
          # 1. Update Kubernetes manifests
          # 2. Apply to staging cluster
          # 3. Wait for rollout to complete
          # 4. Run smoke tests
          
          # For now, simulate deployment
          sleep 10
          echo "‚úÖ Deployment to staging completed"

      - name: Run staging smoke tests
        run: |
          echo "üß™ Running staging smoke tests..."
          
          # Test health endpoint
          curl -f https://staging.modelcard-generator.terragonlabs.com/health || echo "Health check failed"
          
          # Test basic functionality
          # docker run --rm ${{ needs.build-images.outputs.image-tag }} mcg --version
          
          echo "‚úÖ Smoke tests completed"

      - name: Update staging status
        run: |
          echo "üìù Updating deployment status..."
          # Update deployment tracking (e.g., in database, monitoring system)

  # ==========================================================================
  # Deploy to Production
  # ==========================================================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [strategy, build-images, scan-images]
    if: needs.strategy.outputs.deploy-production == 'true'
    environment:
      name: production
      url: https://modelcard-generator.terragonlabs.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pre-deployment checks
        run: |
          echo "üîç Running pre-deployment checks..."
          
          # Verify image exists and is scannable
          docker manifest inspect ${{ needs.build-images.outputs.image-tag }}
          
          # Check for any critical vulnerabilities
          # (This would typically fail the deployment if critical vulns found)
          
          echo "‚úÖ Pre-deployment checks passed"

      - name: Create deployment
        id: deployment
        uses: actions/github-script@v6
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              description: 'Deploy version ${{ needs.strategy.outputs.version }} to production',
              auto_merge: false,
              required_contexts: []
            });
            return deployment.data.id;

      - name: Deploy to production environment
        run: |
          echo "üöÄ Deploying to production..."
          echo "Image: ${{ needs.build-images.outputs.image-tag }}"
          echo "Version: ${{ needs.strategy.outputs.version }}"
          
          # Production deployment steps:
          # 1. Blue-green deployment
          # 2. Database migrations (if needed)
          # 3. Update load balancer
          # 4. Gradual traffic shift
          # 5. Monitor metrics
          
          # For now, simulate deployment
          sleep 15
          echo "‚úÖ Deployment to production completed"

      - name: Run production smoke tests
        run: |
          echo "üß™ Running production smoke tests..."
          
          # Test health endpoint
          curl -f https://modelcard-generator.terragonlabs.com/health || echo "Health check failed"
          
          # Test critical user journeys
          # Test API endpoints
          # Verify metrics are flowing
          
          echo "‚úÖ Production smoke tests completed"

      - name: Update deployment status - Success
        if: success()
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'success',
              description: 'Deployment completed successfully',
              environment_url: 'https://modelcard-generator.terragonlabs.com'
            });

      - name: Update deployment status - Failure
        if: failure()
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'failure',
              description: 'Deployment failed'
            });

  # ==========================================================================
  # Publish Package to PyPI
  # ==========================================================================
  publish-pypi:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: [strategy, deploy-production]
    if: needs.strategy.outputs.is-release == 'true' && needs.deploy-production.result == 'success'
    environment:
      name: pypi
      url: https://pypi.org/p/modelcard-as-code-generator
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build twine

      - name: Build package
        run: python -m build

      - name: Check package
        run: twine check dist/*

      - name: Publish to Test PyPI first
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.TEST_PYPI_API_TOKEN }}
        run: |
          twine upload --repository testpypi dist/*

      - name: Test installation from Test PyPI
        run: |
          sleep 60  # Wait for package to be available
          pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ modelcard-as-code-generator==${{ needs.strategy.outputs.version }}
          mcg --version

      - name: Publish to PyPI
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          twine upload dist/*

  # ==========================================================================
  # Post-Deployment Tasks
  # ==========================================================================
  post-deployment:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: [strategy, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    steps:
      - name: Update monitoring dashboards
        run: |
          echo "üìä Updating monitoring dashboards..."
          # Update Grafana dashboards
          # Update PagerDuty rules
          # Update documentation

      - name: Send notifications
        run: |
          echo "üì¢ Sending deployment notifications..."
          
          # Slack notification
          if [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
            echo "‚úÖ Production deployment successful for version ${{ needs.strategy.outputs.version }}"
          fi
          
          if [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            echo "‚úÖ Staging deployment successful for version ${{ needs.strategy.outputs.version }}"
          fi

      - name: Update release notes
        if: needs.strategy.outputs.is-release == 'true'
        run: |
          echo "üìù Updating release notes..."
          # Generate and update release notes
          # Update changelog
          # Send release announcement

      - name: Cleanup old deployments
        run: |
          echo "üßπ Cleaning up old deployments..."
          # Remove old container images
          # Clean up old releases
          # Archive old logs

  # ==========================================================================
  # Deployment Status Summary
  # ==========================================================================
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    if: always()
    needs: [strategy, deploy-staging, deploy-production, publish-pypi, post-deployment]
    steps:
      - name: Deployment Summary
        run: |
          echo "# Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.strategy.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.deploy-staging.result }}" != "skipped" ]]; then
            if [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
              echo "‚úÖ **Staging Deployment:** Success" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚ùå **Staging Deployment:** Failed" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          if [[ "${{ needs.deploy-production.result }}" != "skipped" ]]; then
            if [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
              echo "‚úÖ **Production Deployment:** Success" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚ùå **Production Deployment:** Failed" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          if [[ "${{ needs.publish-pypi.result }}" != "skipped" ]]; then
            if [[ "${{ needs.publish-pypi.result }}" == "success" ]]; then
              echo "‚úÖ **PyPI Publishing:** Success" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚ùå **PyPI Publishing:** Failed" >> $GITHUB_STEP_SUMMARY
            fi
          fi